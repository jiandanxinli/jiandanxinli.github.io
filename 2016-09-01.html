<!DOCTYPE html><html lang="zh-CN"><head><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>Riot.js 代码风格指南 · 简单心理技术团队</title><meta content="Riot.js 是一个比 React.js 和 Vue.js 更轻量的前端框架。但作为灵活的代价，团队协作时需要一份代码风格指南以保证代码风格的一致。" name="description" /><link href="/stylesheets/app.css" rel="stylesheet" /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="/images/favicon.ico" rel="icon" /></head><body><div class="animated fadeInDown"><div class="header container"><a class="logo" href="/"><img src="/images/logo.png" alt="Logo" /></a><h1><a href="/">简单心理 · 技术团队</a></h1><a class="github" href="https://github.com/jiandanxinli">github.com/jiandanxinli</a></div></div><div class="animated_container"><div class="content container animated fadeIn delay"><h2>Riot.js 代码风格指南</h2><div class="meta"><span class="date">2016-09-01</span><span class="author">Ben</span></div><blockquote>Riot.js 是一个比 React.js 和 Vue.js 更轻量的前端框架。但作为灵活的代价，团队协作时需要一份代码风格指南以保证代码风格的一致。</blockquote><p>本文节选翻译自 <a href="https://github.com/voorhoede/riotjs-style-guide">https://github.com/voorhoede/riotjs-style-guide</a></p>

<h3>宗旨</h3>

<p>本指南的目标是提供一份统一的 Riot.js 代码风格指南，以使你的项目达到以下效果：</p>

<ul>
<li>帮助开发人员理解和查找代码；</li>
<li>方便 IDE 高亮代码和提供协助；</li>
<li>方便构建工具构建代码；</li>
<li>方便缓存、打包和分离代码。</li>
</ul>

<p>本指南受 John Papa 的 <a href="https://github.com/johnpapa/angular-styleguide">AngularJS Style Guide</a> 启发。</p>

<h3>示例</h3>

<p>这些是按照本指南编写的示例项目：<a href="https://voorhoede.github.io/riotjs-demos/">https://voorhoede.github.io/riotjs-demos/</a></p>

<h3>正文</h3>

<h4>模块化开发</h4>

<p>让你的代码模块化，并保证其业务逻辑小而清晰。</p>

<p>模块是应用的组成部分，Riot.js 可以方便的构建和组织模块。</p>

<p><strong>为什么要这么做？</strong></p>

<p>无论对于你还是他人，小模块都是便于阅读、理解、维护、重用和调试的最佳选择。</p>

<p><strong>如何做？</strong></p>

<p>每个模块都需要符合 <a href="https://addyosmani.com/first/">FIRST</a> 原则：专注（Focused，<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">单一职责</a>）、独立（Independent）、可复用（Reusable）、简洁（Small）和可测试（Testable）。</p>

<p>如果你的模块功能太多，导致体积臃肿，请把它切分成多个小模块。比如确保每个模块的代码不超过 100 行，并使其与其它模块隔离。</p>

<p><strong>小贴士</strong></p>

<p>如果你使用 AMD 或 CommonJS 来加载模块，可以在命令行中加上<code>--modular</code>参数</p>
<pre class="highlight plaintext"><code># enable AMD and CommonJS
riot --modular
</code></pre>
<h4>模块的命名</h4>

<p>模块的名字代表模块的用途，需要遵守以下要求：</p>

<ul>
<li>恰当的含义：避免过于具体或过于抽象；</li>
<li>简短：2 ~ 3 个单词；</li>
<li>顺口：不绕口，方便交流；</li>
<li>符合 W3C 的<a href="https://www.w3.org/TR/custom-elements/">自定义标签标准</a>，使用连字符，避开保留名称；</li>
<li>以对象作为名字的前缀。除非模块非常通用，否则不要只使用一个词作为名字。</li>
</ul>

<p><strong>为什么要这么做？</strong></p>

<ul>
<li>模块间通过名字来通讯，所以名字必须有恰当的含义、简短且顺口；</li>
<li>名字将作为标签名写入 HTML 中，所以必须符合 HTML 的规范。</li>
</ul>

<p><strong>如何做？</strong></p>
<pre class="highlight html"><code><span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="nt">&lt;app-header</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;user-list</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;range-slider</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- 避免 --&gt;</span>
<span class="nt">&lt;btn-group</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 虽然简短，但绕口，可以用 `button-group` 替代 --&gt;</span>
<span class="nt">&lt;ui-slider</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 所有的模块都是 UI 模块，所以 ui 在这里没有意义 --&gt;</span>
<span class="nt">&lt;slider</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 不符合 W3C 的自定义标签标准 --&gt;</span>
</code></pre>
<h4>一个模块一个文件夹</h4>

<p>构建时把一个模块的所有文件打包成一个文件。</p>

<p><strong>为什么这么做？</strong></p>

<p>打包文件方便查找和重用。</p>

<p><strong>如何做？</strong></p>

<p>把模块名作为文件夹的名字和文件前缀，后缀为文件类型。</p>
<pre class="highlight plaintext"><code>modules/
└── my-example/
    ├── my-example.tag.html
    ├── my-example.less
    ├── ...
    └── README.md
</code></pre>
<p>如果你的模块里有子模块，可以把子模块作为子文件夹。</p>
<pre class="highlight plaintext"><code>modules/
├── radio-group/
|   └── radio-group.tag.html
└── search-form/
    ├── search-form.tag.html
    ├── ...
    └── search-filters/
        └── search-filters.tag.html
</code></pre>
<h4>使用 <code>.tag.html</code> 作为文件后缀</h4>

<p>Riot.js 建议使用 <code>.tag</code> 作为模块的文件名后缀，虽然它的本质是一个自定义标签。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>告诉开发者这不仅仅是一个 html 文件，而是 Riot.js 模块；</li>
<li>帮助 IDE 识别文件类型。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>如果在<a href="http://riotjs.com/guide/compiler/#in-browser-compilation">浏览器端使用</a>，可以这么写：</p>
<pre class="highlight html"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"path/to/modules/my-example/my-example.tag.html"</span> <span class="na">type=</span><span class="s">"riot/tag"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre>
<p><a href="http://riotjs.com/guide/compiler/#pre-compilation">预编译</a>时，需要加上<a href="http://riotjs.com/guide/compiler/#custom-extension">后缀参数</a>：</p>
<pre class="highlight plaintext"><code>riot --ext tag.html modules/ dist/tags.js
</code></pre>
<p>如果你使用 <a href="https://github.com/srackham/tag-loader">Webpack tag loader</a>，需要<a href="http://webpack.github.io/docs/using-loaders.html#configuration">设置 loader</a>：</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w"> </span><span class="err">test:</span><span class="w"> </span><span class="err">/\.tag.html$/,</span><span class="w"> </span><span class="err">loader:</span><span class="w"> </span><span class="err">'tag'</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre>
<h4>在自定义标签里使用 <code>&lt;script&gt;</code> 标签</h4>

<p>Riot.js 支持在<a href="http://riotjs.com/guide/#no-script-tag">自定义标签里不使用 <code>&lt;script&gt;</code> 标签</a>，但你需要把 Javascript 代码写在 <code>&lt;script&gt;</code> 标签里。这可以让代码更易于理解以及避免 IDE 识别混乱。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>避免非脚本语言被解读为脚本语言；</li>
<li>便于 IDE 识别；</li>
<li>明确脚本从哪里开始，在哪里结束。</li>
</ul>

<p><strong>如何做？</strong></p>
<pre class="highlight html"><code><span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="nt">&lt;my-example&gt;</span>
    <span class="nt">&lt;h1&gt;</span>The year is { this.year }<span class="nt">&lt;/h1&gt;</span>

    <span class="nt">&lt;script&gt;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">year</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()).</span><span class="nx">getUTCFullYear</span><span class="p">();</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/my-example&gt;</span>

<span class="c">&lt;!-- 避免 --&gt;</span>
<span class="nt">&lt;my-example&gt;</span>
    <span class="nt">&lt;h1&gt;</span>The year is { this.year }<span class="nt">&lt;/h1&gt;</span>

    this.year = (new Date()).getUTCFullYear();
<span class="nt">&lt;/my-example&gt;</span>
</code></pre>
<h4>保持自定义标签中的逻辑简洁</h4>

<p>Riot.js 提供的标签内置语法支持 Javascript 语法，但这并不表示建议你在其中编写复杂的代码。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>复杂的内置脚本会导致难以阅读；</li>
<li>复杂的内置脚本难以重用；</li>
<li>IDE 无法准确识别内置脚本。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>把复杂的内置脚本移到模块变量或模块方法里。</p>
<pre class="highlight html"><code><span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="nt">&lt;my-example&gt;</span>
    { year() + '-' + month() }

    <span class="nt">&lt;script&gt;</span>
        <span class="kr">const</span> <span class="nx">twoDigits</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="s1">'0'</span> <span class="o">+</span> <span class="nx">num</span><span class="p">).</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">month</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">twoDigits</span><span class="p">((</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()).</span><span class="nx">getUTCMonth</span><span class="p">()</span> <span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">year</span>  <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()).</span><span class="nx">getUTCFullYear</span><span class="p">();</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/my-example&gt;</span>

<span class="c">&lt;!-- 避免 --&gt;</span>
<span class="nt">&lt;my-example&gt;</span>
    { (new Date()).getUTCFullYear() + '-' + ('0' + ((new Date()).getUTCMonth()+1)).slice(-2) }
<span class="nt">&lt;/my-example&gt;</span>
</code></pre>
<h4>保持参数简洁</h4>

<p>Riot.js 支持通过自定义属性给模块添加参数，比如 <code>&lt;my-tag my-attr=&quot;{ value }&quot; /&gt;</code>，可以在模块中通过 <code>opts.MyAttr</code> 获取参数。</p>

<p>尽管 Riot.js 支持使用复杂的原生 Javascript 语法来传递参数，但我们应保持参数的简洁，只使用标准的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">Javascript 类型</a>，如字符串、数字、函数等。</p>

<p>允许的例外情况是只能使用复杂对象来传递参数（如一组对象、递归模块等）或通用的业务对象（如 <code>Product</code>）。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>每个属性作为一个独立参数，可以让参数易于阅读和理解；</li>
<li>只使用默认的 Javascript 类型可以让代码风格更接近 HTML 的原生风格；</li>
<li>复杂的参数会导致难以理解和重构，导致技术债务。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>每个属性作为一个独立的参数，参数值为 Javascript 原生类型。</p>
<pre class="highlight html"><code><span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="nt">&lt;range-slider</span>
    <span class="na">values=</span><span class="s">"[10, 20]"</span>
    <span class="na">min=</span><span class="s">"0"</span>
    <span class="na">max=</span><span class="s">"100"</span>
    <span class="na">step=</span><span class="s">"5"</span>
    <span class="na">on-slide=</span><span class="s">"{ updateInputs }"</span>
    <span class="na">on-end=</span><span class="s">"{ updateResults }"</span>
    <span class="nt">/&gt;</span>

<span class="c">&lt;!-- 避免 --&gt;</span>
<span class="nt">&lt;range-slider</span> <span class="na">config=</span><span class="s">"{ complexConfigObject }"</span><span class="nt">&gt;</span>

<span class="c">&lt;!-- 例外: 迭代菜单模块 --&gt;</span>
<span class="nt">&lt;menu-item&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"{ opts.url }"</span><span class="nt">&gt;</span>{ opts.text }<span class="nt">&lt;/a&gt;</span>
    <span class="nt">&lt;ul</span> <span class="na">if=</span><span class="s">"{ opts.items }"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">"{ item in opts.items }"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;menu-item</span>
                <span class="na">text=</span><span class="s">"{ item.text }"</span>
                <span class="na">url=</span><span class="s">"{ item.url }"</span>
                <span class="na">items=</span><span class="s">"{ item.items }"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/li&gt;</span>
    <span class="nt">&lt;/ul&gt;</span>
<span class="nt">&lt;/menu-item&gt;</span>
</code></pre>
<h4>初始化参数</h4>

<p>在 Riot.js 中，参数是模块的 API。一个健壮的参数初始化过程，可以方便他人使用你的模块。</p>

<p>模块的参数可能是 Riot.js 的表达式（<code>attr=&quot;{ var }&quot;</code>）、纯字符串（<code>attr=&quot;value&quot;</code>）或不存在。你需要初始化处理这些情况。</p>

<p><strong>为什么这么做？</strong></p>

<p>初始化参数可以确保你的模块总是可以正常运行。哪怕其他开发者将其用于超出你预期的用途。</p>

<p><strong>如何做？</strong></p>

<ul>
<li>给参数设置默认值；</li>
<li>使用类型转换，将值转换成期望的类型；</li>
<li>在使用参数前，先检查参数是否存在。</li>
</ul>

<p>在 <a href="http://riotjs.com/guide/#example">Riot.js 的示例</a> 中，可以把代码进行如下改进：</p>
<pre class="highlight javascript"><code><span class="k">this</span><span class="p">.</span><span class="nx">items</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">items</span> <span class="o">||</span> <span class="p">[];</span> <span class="c1">// 设置默认值为空数组</span>
</code></pre>
<p>这样改进后，可以让模块在以下情况中正常运作：</p>
<pre class="highlight html"><code><span class="nt">&lt;todo</span> <span class="na">items=</span><span class="s">"{ [{ title:'Apples' }, { title:'Oranges', done:true }] }"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- 传入参数时 --&gt;</span>
<span class="nt">&lt;todo&gt;</span> <span class="c">&lt;!-- 未传入参数时 --&gt;</span>
</code></pre>
<p>对于 <code>&lt;range-slider&gt;</code> 这种模块，我们预期其参数都是数字类型，可以这么写：</p>
<pre class="highlight javascript"><code><span class="c1">// 如果没有传入 step，就设为默认值</span>
<span class="k">this</span><span class="p">.</span><span class="nx">step</span> <span class="o">=</span> <span class="o">!</span><span class="nb">isNaN</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">step</span><span class="p">))</span> <span class="p">?</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">step</span><span class="p">)</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</code></pre>
<p>以此确保以下情况都可以正常运行：</p>
<pre class="highlight html"><code><span class="nt">&lt;range-slider&gt;</span> <span class="c">&lt;!-- 全部使用默认值 --&gt;</span>
<span class="nt">&lt;range-slider</span> <span class="na">step=</span><span class="s">"5"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- 将字符串 "5" 转变成数字 5 --&gt;</span>
<span class="nt">&lt;range-slider</span> <span class="na">step=</span><span class="s">"{ x }"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- 使用变量 x --&gt;</span>
</code></pre>
<p>当 <code>&lt;range-slider&gt;</code> 模块支持可选的 <code>on-slide</code> 事件时，需要在使用前确认是否传入了回调：</p>
<pre class="highlight javascript"><code><span class="nx">slider</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'slide'</span><span class="p">,</span> <span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">handle</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">onSlide</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">opts</span><span class="p">.</span><span class="nx">onSlide</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">handle</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>以此确保以下情况可以正常运行：</p>
<pre class="highlight html"><code><span class="nt">&lt;range-slider&gt;</span> <span class="c">&lt;!-- 什么都不触发 --&gt;</span>
<span class="nt">&lt;range-slider</span> <span class="na">on-slide=</span><span class="s">"{ updateInputs }"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- 触发 updateInputs --&gt;</span>
<span class="nt">&lt;range-slider</span> <span class="na">on-slide=</span><span class="s">"invalid option"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- 什么都不触发 --&gt;</span>
</code></pre>
<h4>将 this 改名为 tag</h4>

<p>在 Riot.js 模块内，<code>this</code> 指向模块实例，把 <code>tag</code> 赋值为 <code>this</code> 后，可以在不同的作用域下调用模块实例。</p>

<p><strong>为什么这么做？</strong></p>

<p>将 <code>tag</code> 赋值为实例变量，其它开发者就可以方便的调用了。</p>

<p><strong>如何做？</strong></p>
<pre class="highlight javascript"><code><span class="cm">/* 推荐 */</span>

<span class="c1">// ES5 的赋值写法</span>
<span class="kd">var</span> <span class="nx">tag</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onresize</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">tag</span><span class="p">.</span><span class="nx">adjust</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ES6 中可以把 tag 赋值为常量</span>
<span class="kr">const</span> <span class="nx">tag</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onresize</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">tag</span><span class="p">.</span><span class="nx">adjust</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ES6 中也可以使用 =&gt; 来继续使用 this</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onresize</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">adjust</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* 避免 */</span>
<span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="c1">// 等等</span>
</code></pre>
<h4>在顶部声明变量</h4>

<p>在 Riot.js 的模块中，你可以任意声明变量和方法，但这会导致可读性问题。所以建议把变量和方法按顺序在顶部声明。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>在顶部声明变量和方法，可以方便开发者得知可以使用哪些变量和方法；</li>
<li>按字母顺序排列可以便于查找；</li>
<li>将方法放在后面，可以隐藏执行细节，便于一瞥全局。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>把变量声明和方法移到顶部。</p>
<pre class="highlight javascript"><code><span class="cm">/* 推荐 */</span>
<span class="kd">var</span> <span class="nx">tag</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">todos</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="nx">add</span><span class="p">;</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">edit</span> <span class="o">=</span> <span class="nx">edit</span><span class="p">;</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">toggle</span> <span class="o">=</span> <span class="nx">toggle</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">edit</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">toggle</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>   

<span class="cm">/* 避免 */</span>
<span class="kd">var</span> <span class="nx">tag</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

<span class="nx">tag</span><span class="p">.</span><span class="nx">todos</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="nx">tag</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">edit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="nx">tag</span><span class="p">.</span><span class="nx">toggle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre>
<p>你也可以把 <code>mixins</code> 和 <code>observables</code> 放在顶部：</p>
<pre class="highlight javascript"><code><span class="cm">/* recommended */</span>
<span class="kd">var</span> <span class="nx">tag</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="c1">// alphabetized properties</span>
<span class="c1">// alphabetized methods</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">mixin</span><span class="p">(</span><span class="s1">'someBehaviour'</span><span class="p">);</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'mount'</span><span class="p">,</span> <span class="nx">onMount</span><span class="p">);</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'update'</span><span class="p">,</span> <span class="nx">onUpdate</span><span class="p">);</span>
<span class="c1">// etc</span>
</code></pre>
<h4>避免使用非标准的 ES6 语法</h4>

<p>Riot.js 支持<a href="http://riotjs.com/guide/#tag-syntax">模仿 ES6 的方法声明语法</a>，把 <code>methodName() { }</code> 编译成 <code>this.methodName = function() {}.bind(this)</code>。但这并不是 ES6 的标准语法。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>这并不是 ES6 的标准语法，会造成开发者的困扰；</li>
<li>IDE 无法准确识别这种语法；</li>
<li>这种语法无法清晰表达其作用。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>使用 <code>tag.methodName =</code> 替代 <code>methodName() { }</code>。</p>
<pre class="highlight javascript"><code><span class="cm">/* 推荐 */</span>
<span class="kd">var</span> <span class="nx">tag</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">todos</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">tag</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="nx">add</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">add</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">tag</span><span class="p">.</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">tag</span><span class="p">.</span><span class="nx">todos</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="na">title</span><span class="p">:</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">text</span> <span class="p">});</span>
        <span class="nx">tag</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 避免 */</span>
<span class="nx">todos</span> <span class="o">=</span> <span class="p">[];</span>

<span class="nx">add</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">todos</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="na">title</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">text</span> <span class="p">});</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong>小贴士</strong></p>

<p>可以加上<a href="http://riotjs.com/guide/compiler/#no-transformation">禁用 ES6 的参数</a>，来避免编译这种语法：</p>
<pre class="highlight plaintext"><code>riot --type none
</code></pre>
<h4>避免使用 <code>tag.parent</code></h4>

<p>Riot.js 支持<a href="http://riotjs.com/guide/#nested-tags">嵌套模块</a>，可以通过 <code>tag.parent</code> 访问父模块。但这种行为违反了 <a href="https://addyosmani.com/first/">FIRST</a> 原则，应当避免使用。</p>

<p>例外的情况是在循环中，且子对象是匿名模块。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>每个模块需运行在自己的作用域中，不同模块间保持隔离；</li>
<li>如果一个模块需要访问父模块，那它将无法在不同的环境下复用；</li>
<li>允许访问和修改父模块，可能会导致不可预期的错误。</li>
</ul>

<p><strong>如何做？</strong></p>

<ul>
<li>把需要的值从父模块传入子模块；</li>
<li>父模块以回调的形式监听子模块的事件，以修改自身。</li>
</ul>
<pre class="highlight html"><code><span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="nt">&lt;parent-tag&gt;</span>
    <span class="nt">&lt;child-tag</span> <span class="na">value=</span><span class="s">"{ value }"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 把值传入子模块 --&gt;</span>
<span class="nt">&lt;/parent-tag&gt;</span>

<span class="nt">&lt;child-tag&gt;</span>
    <span class="nt">&lt;span&gt;</span>{ opts.value }<span class="nt">&lt;/span&gt;</span> <span class="c">&lt;!-- 使用父模块传入的值 --&gt;</span>
<span class="nt">&lt;/child-tag&gt;</span>

<span class="c">&lt;!-- 避免 --&gt;</span>
<span class="nt">&lt;parent-tag&gt;</span>
    <span class="nt">&lt;child-tag</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/parent-tag&gt;</span>

<span class="nt">&lt;child-tag&gt;</span>
    <span class="nt">&lt;span&gt;</span>value: { parent.value }<span class="nt">&lt;/span&gt;</span> <span class="c">&lt;!-- 不要这么做 --&gt;</span>
<span class="nt">&lt;/child-tag&gt;</span>
</code></pre><pre class="highlight html"><code><span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="nt">&lt;parent-tag&gt;</span>
    <span class="nt">&lt;child-tag</span> <span class="na">on-event=</span><span class="s">"{ methodToCallOnEvent }"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 传入回调函数 --&gt;</span>
    <span class="nt">&lt;script&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">methodToCallOnEvent</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span><span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;parent-tag&gt;</span>

<span class="nt">&lt;child-tag&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"{ opts.onEvent }"</span><span class="nt">&gt;&lt;/button&gt;</span> <span class="c">&lt;!-- 事件触发时通知父模块 --&gt;</span>
<span class="nt">&lt;/child-tag&gt;</span>

<span class="c">&lt;!-- 避免 --&gt;</span>
<span class="nt">&lt;parent-tag&gt;</span>
    <span class="nt">&lt;child-tag</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;script&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">methodToCallOnEvent</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span><span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;parent-tag&gt;</span>

<span class="nt">&lt;child-tag&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"{ parent.methodToCallOnEvent }"</span><span class="nt">&gt;&lt;/button&gt;</span> <span class="c">&lt;!-- 不要这么做 --&gt;</span>
<span class="nt">&lt;/child-tag&gt;</span>
</code></pre><pre class="highlight html"><code><span class="c">&lt;!-- 允许的例外情况 --&gt;</span>
<span class="nt">&lt;parent-tag&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">each=</span><span class="s">"{ item in items }"</span>
        <span class="na">onclick=</span><span class="s">"{ parent.onEvent }"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- button 不是 Riot.js 的模块 --&gt;</span>
        { item.text }
    <span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;script&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">onEvent</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">item</span><span class="p">.</span><span class="nx">text</span><span class="p">);</span> <span class="p">}</span><span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/parent-tag&gt;</span>
</code></pre>
<h4>使用 <code>each ... in</code> 语法</h4>

<p>Riot.js 支持多种<a href="http://riotjs.com/guide/#loops">循环的语法</a>：数组可以写成 <code>each=&quot;{ item in items }&quot;</code>；对象可以写成 <code>each=&quot;{ key, value in items }&quot;</code>；以及简写 <code>each=&quot;{ items }&quot;</code>。但这种简写会导致混淆，所以建议用 <code>each ... in</code>。</p>

<p><strong>为什么这么做？</strong></p>

<p>当 Riot.js 执行循环语句时，会把当前对象放到 <code>this</code> 中，这种做法并不直观，可能会引起开发者的困扰。</p>

<p><strong>如何做？</strong></p>

<p>使用 <code>each=&quot;{ item in items }&quot;</code> 或 <code>each=&quot;{ key, value in items }&quot;</code> 替代 <code>each=&quot;{ items }&quot;</code>。</p>
<pre class="highlight html"><code><span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">"{ item in items }"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;label</span> <span class="na">class=</span><span class="s">"{ completed: item.done }"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="na">checked=</span><span class="s">"{ item.done }"</span><span class="nt">&gt;</span> { item.title }
        <span class="nt">&lt;/label&gt;</span>
    <span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span>

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">"{ key, item in items }"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;label</span> <span class="na">class=</span><span class="s">"{ completed: item.done }"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="na">checked=</span><span class="s">"{ item.done }"</span><span class="nt">&gt;</span> { key }. { item.title }
        <span class="nt">&lt;/label&gt;</span>
    <span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span>

<span class="c">&lt;!-- 避免 --&gt;</span>
<span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li</span> <span class="na">each=</span><span class="s">"{ items }"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;label</span> <span class="na">class=</span><span class="s">"{ completed: done }"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="na">checked=</span><span class="s">"{ done }"</span><span class="nt">&gt;</span> { title }
        <span class="nt">&lt;/label&gt;</span>
    <span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span>
</code></pre>
<h4>将样式放在独立的文件</h4>

<p>为了给开发者提供便利，Riot.js 允许在模块中<a href="http://riotjs.com/guide/#tag-styling">嵌套 <code>&lt;style&gt;</code></a>，并提供了 <a href="http://riotjs.com/guide/#scoped-css">scope</a> 功能来限制样式的作用域，但这并不是真正的样式隔离。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>独立的样式文件可以让浏览器更容易的读取，并且避免因模块加载出错或者未加载而导致问题；</li>
<li>独立的样式文件可以方便的进行预编译（如 Sass、PostCSS 等）；</li>
<li>独立的样式文件可以独立地进行压缩、构建和缓存，这样有利于提升性能；</li>
<li>Riot.js 并没有额外的功能提供给内嵌样式。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>将样式拆分为独立文件放在模块文件夹内：</p>
<pre class="highlight plaintext"><code>my-example/
├── my-example.tag.html
├── my-example.(css|less|scss)    &lt;-- external stylesheet next to tag file
└── ...
</code></pre>
<h4>使用标签名字作为样式的作用域</h4>

<p>Riot.js 的模块是一个自定义标签，标签名非常适合作为样式的作用域。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>使用标签名作为样式的作用域，可以让样式效果更可预期；</li>
<li>统一的名字便于开发者理解。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>使用标签名作为样式的父类或作用域。</p>
<pre class="highlight css"><code><span class="c">/* 推荐 */</span>
<span class="nt">my-example</span> <span class="p">{</span> <span class="p">}</span>
<span class="nt">my-example</span> <span class="nt">li</span> <span class="p">{</span> <span class="p">}</span>
<span class="nc">.my-example__item</span> <span class="p">{</span> <span class="p">}</span>

<span class="c">/* 避免 */</span>
<span class="nc">.my-alternative</span> <span class="p">{</span> <span class="p">}</span> <span class="c">/* not scoped to tag or module name */</span>
<span class="nc">.my-parent</span> <span class="nc">.my-example</span> <span class="p">{</span> <span class="p">}</span> <span class="c">/* .my-parent is outside scope, so should not be used in this file */</span>
</code></pre>
<p><strong>小贴士</strong></p>

<p>如果使用 2.3.17 之后的版本，可以使用 <a href="http://riotjs.com/guide/#html-elements-as-tags"><code>[data-is=&quot;my-example&quot;]</code></a> 来替代 <code>.my-example</code></p>

<h4>为模块添加说明文档</h4>

<p>一个模块包括了属性和方法，为了便于其他开发人员使用，需要写一份文档来说明这些属性和方法。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>文档帮助开发者快速了解模块的整体情况，而不需要阅读具体的代码。这使得模块更易于使用；</li>
<li>文档里标明了模块的属性信息，可以让只想使用（而非开发）它的人快速上手；</li>
<li>文档帮助开发者理清哪些内容是对外暴露的，更新时需要考虑兼容性；</li>
<li><code>README.md</code> 是标准的说明文件格式，像 Github 之类的代码托管工具，可以方便的展示和阅读这份文件。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>添加 <code>README.md</code> 到模块文件夹：</p>
<pre class="highlight plaintext"><code>range-slider/
├── range-slider.tag.html
├── range-slider.less
└── README.md
</code></pre>
<p>在文档中，描述该模块的功能和使用方法，并说明其自定义属性和方法的含义和用法。</p>
<pre class="highlight markdown"><code><span class="gh"># Range slider</span>

<span class="gu">## Functionality</span>

The range slider lets the user to set a numeric range by dragging a handle on a slider rail for both the start and end value.

This module uses the <span class="p">[</span><span class="nv">noUiSlider</span><span class="p">](</span><span class="sx">http://refreshless.com/nouislider/</span><span class="p">)</span> for cross browser and touch support.

<span class="gu">## Usage</span>

<span class="sb">`&lt;range-slider&gt;`</span> supports the following custom tag attributes:

| attribute | type | description
| --- | --- | ---
| <span class="sb">`min`</span> | Number | number where range starts (lower limit).
| <span class="sb">`max`</span> | Number | Number where range ends (upper limit).
| <span class="sb">`values`</span> | Number<span class="p">[</span><span class="nv">] *optional* | Array containing start and end value.  E.g. `values="[10, 20</span><span class="p">]</span>"<span class="sb">`. Defaults to `</span><span class="p">[</span><span class="nv">opts.min, opts.max</span><span class="p">]</span><span class="err">`</span>.
| <span class="sb">`step`</span> | Number <span class="ge">*optional*</span> | Number to increment / decrement values by. Defaults to 1.
| <span class="sb">`on-slide`</span> | Function <span class="ge">*optional*</span> | Function called with <span class="sb">`(values, HANDLE)`</span> while a user drags the start (<span class="sb">`HANDLE == 0`</span>) or end (<span class="sb">`HANDLE == 1`</span>) handle. E.g. <span class="sb">`on-slide={ updateInputs }`</span>, with <span class="sb">`tag.updateInputs = (values, HANDLE) =&gt; { const value = values[HANDLE]; }`</span>.
| <span class="sb">`on-end`</span> | Function <span class="ge">*optional*</span> | Function called with <span class="sb">`(values, HANDLE)`</span> when user stops dragging a handle.

For customising the slider appearance see the <span class="p">[</span><span class="nv">Styling section in the noUiSlider docs</span><span class="p">](</span><span class="sx">http://refreshless.com/nouislider/more/#section-styling</span><span class="p">)</span>.
</code></pre>
<h4>增加模块示例</h4>

<p>增加 <code>*.demo.html</code> 示例文件，来表示模块该如何被使用。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>模块示例证明该模块可以被独立使用；</li>
<li>模块示例让使用者在查看文档和代码前就对模块有个大体概念；</li>
<li>示例中可以展示该模块所有可能的使用方法。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>添加 <code>*.demo.html</code> 文件到模块文件夹：</p>
<pre class="highlight plaintext"><code>city-map/
├── city-map.tag.html
├── city-map.demo.html
├── city-map.css
└── ...
</code></pre>
<p>在示例文件中，需要：</p>

<ul>
<li>引入 <code>riot+compiler.min.js</code> 来解析和执行示例；</li>
<li>引入模块文件，如 <code>./city-map.tag.html</code>；</li>
<li>创建一个 <code>demo</code> 标签用于嵌入模块；</li>
<li>在 <code>&lt;demo&gt;</code> 中编写示例；</li>
<li>可以给 <code>demo</code> 标签加上 <code>aria-label</code> 属性来说明示例的内容；</li>
<li>使用 <code>riot.mount(&#39;demo&#39;, {})</code> 来初始化。</li>
</ul>

<p>下面是一个例子：</p>
<pre class="highlight html"><code><span class="c">&lt;!-- modules/city-map/city-map.demo.html: --&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>city-map demos<span class="nt">&lt;/h1&gt;</span>

    <span class="nt">&lt;demo</span> <span class="na">aria-label=</span><span class="s">"City map of London"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;city-map</span> <span class="na">location=</span><span class="s">"London"</span> <span class="nt">/&gt;</span>    
    <span class="nt">&lt;/demo&gt;</span>

    <span class="nt">&lt;demo</span> <span class="na">aria-label=</span><span class="s">"City map of Paris"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;city-map</span> <span class="na">location=</span><span class="s">"Paris"</span> <span class="nt">/&gt;</span>    
    <span class="nt">&lt;/demo&gt;</span>

    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"./city-map.css"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"path/to/riot+compiler.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"riot/tag"</span> <span class="na">src=</span><span class="s">"./city-map.tag.html"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="nx">riot</span><span class="p">.</span><span class="nx">tag</span><span class="p">(</span><span class="s1">'demo'</span><span class="p">,</span><span class="s1">'&lt;yield/&gt;'</span><span class="p">);</span>
        <span class="nx">riot</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">'demo'</span><span class="p">,</span> <span class="p">{});</span>
    <span class="nt">&lt;/script&gt;</span>

    <span class="nt">&lt;style&gt;</span>
        <span class="c">/* add a grey bar with the `aria-label` as demo title */</span>
        <span class="nt">demo</span><span class="nd">:before</span> <span class="p">{</span>
            <span class="nl">content</span><span class="p">:</span> <span class="s1">"Demo: "</span> <span class="n">attr</span><span class="p">(</span><span class="n">aria-label</span><span class="p">);</span>
            <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
            <span class="nl">background</span><span class="p">:</span> <span class="m">#F3F5F5</span><span class="p">;</span>
            <span class="nl">padding</span><span class="p">:</span> <span class="m">.5em</span><span class="p">;</span>
            <span class="nl">clear</span><span class="p">:</span> <span class="nb">both</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="nt">&lt;/style&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre>
<h4>检查模块文件的代码风格</h4>

<p>检查工具可以改进代码风格的一致性并找出语法错误。通过一些额外的配置，我们可以检查 Riot.js 模块的代码风格。</p>

<p><strong>为什么这么做？</strong></p>

<ul>
<li>保证开发者们有一致的代码风格；</li>
<li>提前发现语法错误。</li>
</ul>

<p><strong>如何做？</strong></p>

<p>使用 <a href="http://eslint.org/">ESLint</a> 和 <a href="http://jshint.com/">JSHint</a> 来检查代码风格。</p>

<h4>给你的项目加上 <code>RiotJS Style Guide</code> 标识</h4>

<p>给项目加上标识，并链接到本指南。</p>

<p><a href="https://github.com/voorhoede/riotjs-style-guide"><img src="https://cdn.rawgit.com/voorhoede/riotjs-style-guide/master/riotjs-style-guide.svg" alt="RiotJS Style Guide badge" /></a></p>

<p><strong>为什么这么做？</strong></p>

<p>让其他开发人员知道和了解本指南。</p>

<p><strong>怎么做？</strong></p>

<p>在 markdown 文件中引入：</p>
<pre class="highlight plaintext"><code>[![RiotJS Style Guide badge](https://cdn.rawgit.com/voorhoede/riotjs-style-guide/master/riotjs-style-guide.svg)](https://github.com/voorhoede/riotjs-style-guide)
</code></pre>
<p>在 html 文件中引入：</p>
<pre class="highlight html"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"https://github.com/voorhoede/riotjs-style-guide"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;img</span> <span class="na">alt=</span><span class="s">"RiotJS Style Guide badge"</span>
         <span class="na">src=</span><span class="s">"https://cdn.rawgit.com/voorhoede/riotjs-style-guide/master/riotjs-style-guide.svg"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/a&gt;</span>
</code></pre></div></div><a class="top" href="#">Back to Top</a><div class="footer"><div class="container"><a class="logo" href="https://www.jiandanxinli.com"><img src="/images/logo_text.png" alt="简单心理" /></a><div class="links"><a href="/">Home</a><a href="/feed.xml">Feed</a><a href="https://github.com/jiandanxinli">Github</a><a href="https://www.jiandanxinli.com/pages/37">About</a></div><p>&copy; 2014 - 2016 北京竹间科技有限公司 版权所有</p></div></div></body></html>